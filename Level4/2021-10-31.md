### 2021-10-31

## JPA 변경 감지? 외래키 관리자! (미션 뇌절 기록)
- 우선 내가 하고 싶은 것: 테스트 코드에서 테이블_그룹1에 주문_테이블1, 주문_테이블2 연관관계 매핑
    ```sql
    CREATE TABLE order_table (
        id BIGINT(20) NOT NULL AUTO_INCREMENT,
        table_group_id BIGINT(20),
        number_of_guests INT(11) NOT NULL,
        empty BIT(1) NOT NULL,
        PRIMARY KEY (id)
    );

    CREATE TABLE table_group (
        id BIGINT(20) NOT NULL AUTO_INCREMENT,
        created_date DATETIME NOT NULL,
        PRIMARY KEY (id)
    );

    ALTER TABLE order_table
        ADD CONSTRAINT fk_order_table_table_group
            FOREIGN KEY (table_group_id) REFERENCES table_group (id);
    ```

- CASE1. 우선 오더테이블 만들고 저장하고, 테이블그룹에서 오더테이블의 테이블그룹 지정해주면 알아서 변경감지 되서 뚝딱 처리되겠지?
    ```java
    주문_테이블1.setNumberOfGuests(4);
    주문_테이블1.setEmpty(true);
    주문_테이블1.setTableGroup(null);
    orderTableRepository.save(주문_테이블1);

    주문_테이블2.setNumberOfGuests(2);
    주문_테이블2.setEmpty(true);
    주문_테이블2.setTableGroup(null);
    orderTableRepository.save(주문_테이블2);

    테이블_그룹1 = new TableGroup.Builder()
            .createdDate(LocalDateTime.now())
            .orderTables(Arrays.asList(주문_테이블1, 주문_테이블2))
            .build();
    tableGroupRepository.save(테이블_그룹1);
    ```

- CASE2. 어라 변경감지가 안되네? 이런식으로 수동으로 바꿔준 다음에 다시 저장해야하나?
    ```java
    주문_테이블1.setNumberOfGuests(4);
    주문_테이블1.setEmpty(true);
    주문_테이블1.setTableGroup(null);
    orderTableRepository.save(주문_테이블1);

    주문_테이블2.setNumberOfGuests(2);
    주문_테이블2.setEmpty(true);
    주문_테이블2.setTableGroup(null);
    orderTableRepository.save(주문_테이블2);

    테이블_그룹1 = new TableGroup.Builder()
            .createdDate(LocalDateTime.now())
            .orderTables(Arrays.asList(주문_테이블1, 주문_테이블2))
            .build();
    tableGroupRepository.save(테이블_그룹1);

    주문_테이블1.setTableGroup(테이블_그룹1);
    orderTableRepository.save(주문_테이블1);

    주문_테이블2.setTableGroup(테이블_그룹1);
    orderTableRepository.save(주문_테이블2);
    ```
    - 사실 이러면 되긴함.
    - 다만 주문_테이블.setTableGroup()은 굳이 할 필요 없음 (테이블_그룹1의 생성로직에 setTableGroup(this) 해줘서)
    - 쨋든 테이블 그룹을 만들고, save를 한번 더 해주면 되긴함.

- CASE3. 그러면 이런식으로 저장하면 괜찮지 않을까?
    ```java
    주문_테이블1.setNumberOfGuests(4);
    주문_테이블1.setEmpty(true);

    주문_테이블2.setNumberOfGuests(2);
    주문_테이블2.setEmpty(true);

    테이블_그룹1 = new TableGroup.Builder()
            .createdDate(LocalDateTime.now())
            .orderTables(Arrays.asList(주문_테이블1, 주문_테이블2))
            .build();
    tableGroupRepository.save(테이블_그룹1);
    orderTableRepository.save(주문_테이블1);
    orderTableRepository.save(주문_테이블2);
    ```
    - 여기서 외래키 관리자는 OrderTable임.
        - 이말인 즉슨, OrderTable에서만 table_group_id 필드 속성을 가지고 놀 수 있다는 뜻
        - TableGroup에서는 해당 외래키를 그냥 조회해올때만 쓸 수 있음.
    - 따라서 TableGroup을 만들면서 OrderTable들의 tableGroup을 지정해주고,
        - 테이블_그룹1을 저장, 이후에 주문_테이블1/2를 저장하는 순서가 맞음
    - TableGroup의 경우 쿼리가 이렇게 밖에 안나가
        - (이 테이블이 OrderTable에 대해 알 길이 없음)
        - 왜냐하면 OrderTable이 외래키를 담당하는 관리자라서!
        ```
        Hibernate:
            insert
            into
                table_group
                (id, created_date)
            values
                (null, ?)
        2021-10-31 11:10:34.351 TRACE 18148 --- [    Test worker] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [TIMESTAMP] - [2021-10-31T11:10:34.290]
        ```

## Repository에 Save한다는 것? 영속 -> 준영속이 되는건가?

