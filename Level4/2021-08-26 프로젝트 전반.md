### 2021-08-26 프로젝트 전반

## 깃 브랜치 전략
- **놀토의 깃 브랜치 전략 설명해주세요**
    - 우선 놀토의 브랜치는 총 5가지가 있습니다
        - main: 실 배포 브랜치
        - release: 실제 배포 이전 QA를 진행하는 브랜치 + 태그를 달아 main에 병합
        - develop: 다음 버전 출시를 위해 새로운 기능들을 모아두는 브랜치
        - feature: 단일 기능을 개발하는 브랜치
        - hotfix: release/main에서 예상못한 문제 상황이 생기면 수정 개발하는 브랜치
    - feature -> develop 머지시 squash and merge
        - 짜잘하게 기능을 어떤식으로 개발했는지까지 커밋 이력을 남길 필요가 없다 생각
    - develop -> release -> master 머지시 rebase and merge
        - 머지 과정에서 별도 커밋 생성 X

- **깃 플로우네요. 깃헙 플로우 왜 안썼어요?**
    - 깃헙플로우는 마스터는 항상 배포
        - 여기에 병합은 엄격하게!
    - 사실 처음 팀원들과 정할 때 레퍼런스로 봤던 자료가 깃 브랜치였음,,,
    - 구구의 강의도 그랬고
    - 엄격하게 각 브랜치의 역할을 정해서 함부로 main을 건드리지 않는 방식이 좋아보였음

- **아쉬웠던 부분이 있나요? 힘들었던 부분은?**
    - QA와 버그 픽스를 위해 release 브랜치를 만듦
        - 실제로 QA 환경등을 구성해뒀음
        - 하지만 develop 브랜치에 대해 바로바로 피드백을 받아볼 수 있도록 여기도 인프라를 구성해둠
            - 새로운 기능들이 병합댔을때 문제가 없는지 바로바로 확인하기위함
        - 그러다 보니 오히려 release가 했어야 할 역할이 상당 부분 develop에 넘어간 느낌
        - hotfix도 develop에서 따게되는 상황 발생
        - develop에서는 테스트만 돌릴껄 그랬나 싶기도함 혹은 release를 폐기하던가?
        - release는 거의 tag만 붙여 main에 찔러넣는 브랜치로 변질됨
    - main에서 무지성으로 commit을 해버렸었음
        - 앞선 커밋을 참조하는 커밋을 새로 만들어버림
        - 해당 커밋을 develop으로 병합을 안시켜줌
        - 하나의 커밋을 빠뜨린 상태로 주구장창 기능 개발 착수
        - release -> main 할라니까 진짜 충돌 빡세게 났음
            - main 커밋을 하나 지워버리는 불상사 발생

## 웹훅
- **웹훅이 뭔가요?**
    - 웹앱에서 발생한 이벤트를 실시간으로 전달하기 위해서 사용
    - 클라이언트 측에서 서버로 필요한 정보를 물어보는 Polling 방식이 아닌, 서버 측에서 클라이언트에게 필요한 정보 도착하면 알려주는 방식

- **어디에 사용해보셨나요?**
    - 젠킨스와 슬랙봇 알림을 위해 만들어봄
    - 젠킨스(클라이언트), 깃헙(서버)
        - 깃헙에서 머지가 일어나면, 클라이언트인 젠킨스에게 머지가 되었다고 요청을 보냄
    - 슬랙(클라이언트), 놀토 WAS(서버)
        - 놀토 WAS에서 해당 슬랙봇에게 알림 보내줌

- **구현할 수 있겠어요?**
    - 클라이언트 측에서도 요청을 받을 수 있도록 listening 하고 있어야 함...
    - HTML/CSS/JS로만 프론트 만들어봐서 솔직히 자신은 없단 말이지,,,
    - 프론트에서도 서버처럼 요청 받을 수 있는게 있다면 가능하지 않을까?

## CI/CD
- **CI는 뭐에요?**
    - 지속적 통합을 의미
    - 분담하여 코드 작성 완료 시 바로 합쳐 오류에 대한 피드백 받기 쉬움
    - 애자일하게 기능 개발하는 문화와 잘어울림

- **CD는 뭘까요?**
    - 지속적 배포
    - 자동으로 배포되도록 작성

- **무슨 툴 쓰셨어요? 왜요?**
    - 팀원의 추천으로 젠킨스를 사용했음
    - 처음 써보는지라 Freestyle 프로젝트를 사용
    - develop 브랜치에 머지가 일어나면 웹훅을 사용해 젠킨스에서 빌드 및 테스트하도록 설정 (CI)
    - dev 인프라 구성이 이뤄지고 난 후로는 publish over ssh를 통해 dev 서버에 배포하도록 설정

- **젠킨스 쓰면서 느낀 장점?**
    - 머지만해도 바로 CI를 통해 테스트 돌려보는게 좋았음
        - 다 같이 합쳤을 때 이상이 있는지 없는지 판단하기 쉬움
    - 인스턴스 들어가서 쉘스크립트 수동으로 안돌려도돼서 좋았음

- **젠킨스 쓰면서 느낀 단점?**
    - 여러개의 작업이 동시에 돌아가진 않는듯
        - 병렬적 처리가 불가능했나?

## OAuth
- **왜 필요하죠?**
    - 사용자의 민감정보를 관리하지 않으면서 회원으로써의 기능을 제공할 수 있음
        - 비밀번호 암호화 등
    - 사용자들도 OAuth에 친숙하다보니 도입하는 것이 좋겠다 생각함

- **과정 설명 좀 해주세요**
    1. 구글에 클라이언트_ID, 스코프, 리다이렉트_URL을 쿼리스트링으로 넘겨서 로그인 요청
    2. 사용자가 로그인하면 리다이렉트_URL에 Authorization_Code를 곁들여 리다이렉트
    3. Authorization_Code, 클라이언트_ID, 클라이언트_PW를 JSON body나 쿼리스트링에 담아 구글에 요청
    4. 구글에서 사용자의 찐 토큰을 발급해줌
    5. 그걸로 사용자 정보를 스코프 만큼 조회가능
   
- **놀토에서는 어찌 OAuth 활용했죠?**
    1. 프론트에서 구글로 로그인 버튼 클릭
    2. 백엔드에서 클라이언트_ID, 스코프, 리다이렉트_URL를 반환
    3. 프론트에서 구글 주소에 클라이언트_ID, 스코프, 리다이렉트_URL를 포함하여 리다이렉트 
    4. 프론트 단으로 Authorization_Code가 넘어옴
    5. 프론트가 Authorization_Code를 백엔드에 넘겨줌
    6. 백엔드에서 Authorization_Code, 클라이언트_ID, 클라이언트_PW를 JSON body나 쿼리스트링에 담아 구글에 요청
    7. 백엔드에서 구글 사용자 토큰을 발급받음
    8. 백엔드에서 그 토큰 사용하여 사용자 정보 조회 + 로그인 처리
    9. 백엔드에서 놀토만의 토큰을 발급하여 프론트에 넘겨줌
    10. 로그인 끝!
