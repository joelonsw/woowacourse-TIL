### 2021-09-25

## 밸덩 GC
- *참고: https://www.baeldung.com/java-gc-cyclic-references*
- **개요**
    - JVM 구현마다 GC 전략 다 달라. 만드는 놈 마음이야
    - HotSpot JVM을 기준으로 살펴볼게요

- **Reference Counting**
    - 스위프트가 이 방식 씀
    - JVM에서는 이런 GC 알고리즘 안써 안써!
        - `Also, there is no GC algorithm based on reference counting in the JVM.`
    - JavaScript에서도 Mark-And-Sweep 방식 쓴다하네
    - 이건 너무 나태한 구현이야
    - 순환참조도 해결하지 못하는걸?
        - 더블링크드리스트도 가비지로 처리하지 못하는걸?

- **Trading GC**
    - GC root로 부터 reachability 판단
        - 직/간접적으로 루트와 연결되있다면 살아있는 것으로 판단

## JDBC API
- **Java DataBase Connectivity**
    - 자바 프로그램 내에서 DB 종류에 상관없이 DB 관련작업 처리할 수 있도록 도와주는 API

- **JDBC로 SQL 처리**
    - *참고: https://docs.oracle.com/javase/tutorial/jdbc/basics/processingsqlstatements.html*
    1. 연결 설정
        - Datasource와의 연결 설정
        - Connection 객체로 표시
    2. Statement 만들기
        - Statement == SQL을 나타내는 인터페이스
        - ResultSet을 통해 DB 결과 집합을 나타내는 객체 생성
        - stmt = con.createStatement();
        - Statement: 매개 변수 없는 단순 SQL문
        - PreparedStatement: 입력 매개변수 포함할 수 있는 SQL문
        - CallableStatement: 입력 및 출력 매개변수 모두를 저장하는 SQL 문
    3. 쿼리문 실행하기
        - execute: returns `true` if the first object that the query return is a ResultSet object
        - executeQuery: 하나의 ResultSet 객체 반환
        - executeUpdate: returns `Integer` when INSERT, UPDATE, DELETE
    4. ResultSet 처리하기
        ``` Java
        ResultSet rs = stmt.executeQuery(query);
        while (rs.next()) {
            String coffeeName = rs.getString("COF_NAME");
            int supplierID = rs.getInt("SUP_ID");
            float price = rs.getFloat("PRICE");
            int sales = rs.getInt("SALES");
            int total = rs.getInt("TOTAL");
            System.out.println(coffeeName + ", " + supplierID + ", " + price +
                               ", " + sales + ", " + total);
        }
        ```
    5. 연결 종료
        - Connection, Statement, ResultSet 다 쓰고나면 close 메서드 호출해주자
        - try-with-resources를 사용하면 자동으로 close 가능

- **JDBC 코드 보기**
    - 일반적인 코드 구성
    ```java
    Connection conn = null;
    try {
        String jdbcDriver = "jdbc:mysql://localhost:3306/test";
        String dbUser = "joel";
        String dbPass = "joel";
        conn = DriverManager.getConnection(jdbcDriver, dbUser, dbPass);
        ...
    } catch (SQLException ex) {
        // 에러 발생의 경우
    } finally {
        if (conn != null) { try { conn.close(); } catch (SQLException ex) {} }
    }
    ```
    - Statement를 이용한 쿼리 실행
    ```java
    Statement stmt = null;
    ResultSet rs = null;
    try {
        stmt = conn.createStatement();
        int insertedCount = stmt.executeUpdate("insert ...");
        rs = stmt.executeQuery("select * from ...");
        ...
    } catch (SQLException ex) {
        ...
    } finally {
        if (rs != null) try { rs.close(); } catch (SQLException ex) {}
        if (stmt != null) try { stmt.close(); } catch (SQLException ex) {}
    }
    ```
        - Connection.createStatement()를 통해 Statement 생성!
        - Statement가 제공하는 메서드로 쿼리 실행!
            - SELECT: ResultSEt executeQuery(String query)
            - INSERT, UPDATE, DELETE: int executeUpdate(String query)