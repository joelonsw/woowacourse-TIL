### 2021-06-14
  
## 토비의 스프링 5장. 서비스 추상화
- __[UserService의 도입]__
    - Enum을 통해 잘못된 코드를 컴파일 타임에 바로잡자!
    - 빠르게 실행 가능한 포괄적인 테스트를 통해 기능의 추가/수정을 용이하게 하자
    - UserService는 UserDao의 구현 클래스가 변경되더라도 영향 받지 않도록 할 것
        - Data Access Logic의 변경으로 인해 비즈니스 로직 코드를 수정하면 안 됨
    - 객체지향적인 코드는 데이터 가져와서 작업하지 말고, 데이터 갖고있는 객체에게 처리를 요청

- __[트랜잭션 서비스 추상화]__
    - 트랜잭션: 더 이상 나눌 수 없는 단위 작업. "원자성"
    - 테스트용 UserService의 서브클래스를 정의해 특정 시점에서 강제로 예외를 발생시켜보자
        - 해당 테스트에서는 앞선 DB 저장 로직이 반영이 되었음 
        - 모든 사용자의 레벨을 업그레이드하는 작업인 upgradeLevels() 메서드가 하나의 트랜잭션 안에서 동작하지 않았음
            - 전체가 다 성공/실패해야 바람직
        - DB는 그 자체로 완벽한 트랜잭션을 제공하나, 여러개의 SQL을 하나의 메서드에서 사용시 문제 발생
    - 트랜잭션의 경계
        - 애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치
        - 하나의 Connection이 만들어지고 닫히는 범위 안에서 존재
    - JDBC의 트랜잭션은 하나의 Connection을 가져와 사용한 후 닫는 사이에 일어남
        - 트랜잭션이 한 번 시작되면 commit() or rollback() 메서드가 호출될 때까지 작업이 하나의 트랜잭션으로 묶임
        - DAO로 분리해 놓은 데이터 액세스 코드는 메서드 호출마다 새로운 트랜잭션이 만들어지는 구조가 됨
            - 작업이 진행되는 동안 하나의 DB 커넥션을 만들어 놓을 필요가 있음!
    - upgradeLevels()를 하나의 DB 커넥션으로 만드는 방법
        1. Connection 오브젝트를 파라미터로 전달
            - JdbcTemplate 구현 파토남
            - 코드가 지저분해짐
            - Jdbc에 의존적여짐
        2. Spring의 트랜잭션 동기화
            - 트랜잭션 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 저장
            - 이후 호출되는 Dao의 메서드에서는 Connection 가져다가 사용
    - 문제상황 발생! 하나의 트랜잭션 안에 여러가지 DB 데이터 접근 로직은 불가능 *(로컬 트랜잿견은 하나의 DB Connection에 종속)*
        - "글로벌 트랜잭션"을 활용해야 여러개의 DB가 참여하는 작업을 트랜잭션 처리 가능
            - JTA를 활용해야 함
                - 그런데 하이버네이트의 트랜잭션 관리를 JTA 안써...
                    - 또 서비스가 JDBC에 의존적이게 되버림
    - Service와 트랜잭션 API간의 의존을 제거하자
        - Spring에서는 PlatformTransactionManager를 통해 해당 작업이 가능
        - 외부에서 어떤 TransactionManager를 쓸지 Bean을 통해 주입해주자

- __[서비스 추상화와 단일 책임 원칙]__
    - 애플리케이션의 비즈니스 로직과 하위에서 동작하는 로우레벨의 트랜잭션 기술을 분리함
    - UserService와 UserDao, UserService와 PlatformTransactionManager, UserDao와 DataSource 모두 느슨한 결합
        - 이는 DI 덕분에 가능한 구현
    - 단일 책임 원칙을 준수하였기에, 변경 시 대상이 명확해짐
    
- __[메일 서비스 추상화]__
    - 실제 Mail 전송 로직을 테스트하는 것은 비용이 너무 큼
        - 테스트용 DB 설정한 것 마냥 테스트를 해주는 것이 좋아보임
        - JavaMail 같은 자바 표준 기술은 검증이 된 것으로 간주
    - 직접 JavaMail의 구현을 테스트용으로 바꿔치기 하는 것은 내부 구현상 불가능
        - 따라서 테스트 하기 힘든 구조에 "서비스 추상화"를 해줌으로써 테스트해보자
        - LEVEL1 때 배웠던 전략 패턴을 통한 테스트 가능한 구조로 만들기가 생각남
        - JavaMailSender라는 스프링이 제공하는 인터페이스로 관련 클래스를 수정해줌
            - 이후 콘크리트 클래스를 만들어 메일 발송 기능이 잘 동작하는지 확인하면 됨
    - 확장이 불가능한 API를 테스트해야 하는 경우라면, 추상화 계층 도입을 검토할 것!
        - 테스트 환경에서 DI를 다르게 주입하여 테스트를 할 수 있음
    - 테스트 대역
        - 테스트용으로 사용되는 오브젝트
        - 테스트 스텁이 대표적
            - 테스트 대상 오브젝트의 의존객체로 존재하면서 테스트 동안 코드가 정상적으로 수행할 수 있도록 도움
        - Mock Object를 도입하여 테스트 행위 자체를 검토
            - 보통 테스트 방법이라면 검토하기 까다로울 텐데 이를 도입하면 내부 정보까지 검증 가능

## atdd-subway-path 복습하기        
- __어떤 부분을 중점적으로 개발했는가?__
    - JWT 토큰과 ArgumentResolver/Interceptor를 도입하여 사용자에 대한 인가 처리
        - 어떤 필드를 토큰으로 가져야 할까?
        - 토큰을 어디에 저장할까?

- __고민했던 부분, 느꼈던 감정, 페어 프로그래밍 회고__
    - 다시 만난 바다와 페어 프로그래밍
        - 먼저 공부를 하고 미션을 진행하자는 의견에 동의해줘서 이론 학습 이후 미션 구현에 들어갈 수 있었음
        - Spring Web 요청이 들어왔을 때 어떤 관문을 거치는 지 정리해볼 수 있었음
    - 스켈레톤 코드에서는 JWT 토큰에 대한 인가 로직이 AuthService에 포함되어 있었음
        - ArgumentResolver에 AuthService를 주입해주는 형식으로 코드를 작성해야 함
            - 이게 어색하다고 느꼈음
                - ArgumentResolver가 Controller에 들어가기 전에 거치는 단계라고 생각함
                    - Controller에서 Service를 호출하는게 맞지 않나?
            - 따라서 JwtTokenProvider를 ArgumentResolver에 주입하여 활용하기로 함
    - 코니의 리뷰가 상당히 꼼꼼함
    
- __피드백 공유 및 코드가 개선된 포인트 공유__
    - ResponseEntity에 제네릭 타입 지정해 줄 것
        - 없으면 Void로 지정
    - 토큰에는 민감하지 않은 사용자 정보를 넣어두기로 하자
        - JWT 토큰 같은 경우, header와 payload는 그냥 BASE64 인코딩에 불과
            - 토큰이 유출되면 해당 값은 그냥 해독이 가능함
            - 따라서 크게 유출되도 민감하지 않은 정보를 payload에 넣어두는 것이 좋아보임
            - 어차피 JWT 토큰 validation에서 중요한 건 hashing algorithm의 일치여부
            > 사실 JWT의 큰 장점 중 하나가 토큰 자체에 정보를 담을 수 있다는 건데,   
            민감 정보 다 빼고 나면 결국 토큰이 담은 정보만으로는 부족해서 검증 시마다 인증 서버 또는 DB 조회가 불가피해질 수도 있죠  
            서비스 특성에 따라 트레이드오프를 고려해 어떤 정보를 담을지, 만료 기간은 어떻게 가져갈지,   
            리프레시는 어떻게 할지 등을 잘 결정해서 사용하는 게 중요한 것 같아요.  
    - 토큰 유효성 확인을 어디서 하는 것이 좋을까?
        - InterceptorHandler를 통해 DispatcherServlet이 컨트롤러 호출하기 전에 요청 가공해주자
        - ArgumentResolver를 통한 확인을 하려면, 토큰 확인이 필요한 컨트롤러 메서드 마다 `@AuthenticationPrincipal`이 필요함
            - 얘는 토큰에서 필요한 정보를 추출해서 필요한 파라미터 넘겨주기 위함에 더 가깝다
    - JWT 토큰을 어디에 저장하는 것이 좋을까?
        - *참고: https://velog.io/@0307kwon/JWT%EB%8A%94-%EC%96%B4%EB%94%94%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C-localStorage-vs-cookie*
        - localStorage:
        - Cookie:
    - 커스텀 예외를 만들 때, 알맞는 Layer의 예외를 상속받을 것
        - Service Layer에서 던져줄 커스텀 예외를 `org.springframework.dao.EmptyResultDataAccessException` 이걸 상속받음
    - 예외 자체에 `@ResponseStatus`를 정의하는 것 보다 `@ExceptionHandler`를 통해 예외 잡고 ResponseEntity 반환하는 것 추천
        - `@ResponseStatus`를 사용하면 HttpServletResponse.sendError 메서드가 사용됨
            - *참고: https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ResponseStatus.html*
            - 해당 메서드를 호출한다는 것은 Response가 완료되었다 간주하고 더 이상 추가적인 정보를 부여할 수 없다는 뜻
            - 또한 Servlet Container는 HTML 에러 페이지를 반환하기 때문에 REST API 설계와 어울리지 않는 예외처리 방식임
    - `@SQLException`에 대한 처리를 `@ControllerAdvice`에서 하는게 맞을까?
        - Dao에서 발생할 수 있는 예외를 Service에서 잡아, 의미있는 RuntimeException으로 변경해주는 것이 좋을 듯 하다
    - 도메인을 응집도 높게 처리하자
    - 기타 사항
        - 객체에 메시지를 보내 로직 구현할 것
        - 메서드를 만들 떄 오버로딩을 통해 구분하지 말고, 메서드 명으로 확실히 드러내자
        - validation을 통해 필요한 필드를 검사했다면 이를 반환하도록 변경해볼 것

- __개선될 포인트__
    - [PathService에 SubwayMap 도메인 객체를 위한 전처리 로직이 있음]
    

## atdd-subway-fare 복습하기        
- __어떤 부분을 중점적으로 개발했는가?__  
    - 요금 정책 기능을 어떤식으로 구현할 것인가?
        - 요금 정책
            - 도메인을 따로 만들어 if 분기로 구할지
            - Enum으로 관리할 지 
        - 요금을 계산하는 로직
            - 도메인을 따로 만들어 계산시마다 new FareCalculator()
            - 서비스 클래스를 싱글톤으로 등록하여 해당 빈 객체를 사용
    - 프론트 측의 요청에 따른 추가 API 구현
    - 예외 처리를 어떻게 할 것인가?
        - 기능별 패키지에 Exception 패키지를 만들어 해당 기능에서 발생할 예외를 커스텀으로 구현
        - ErrorResponse 클래스를 만들어 예외 발생시 응답할 양식을 통일

- __고민했던 부분, 느꼈던 감정, 페어 프로그래밍 회고__
    - 파피와 아주 야무진 페어프로그래밍
    - 앞선 배포 관련 https 설정, nginx 설치 등이 재미있었음
    - ExceptionHandler를 기능별로 둘지, 아니면 전역에서 하나로 퉁칠지
    - ArgumentResolver에서 Optional을 반환
        - /path 기능 같은 경우 로그인한 사용자가 있어도 되고, 없어도 됨
            - 이를 구현하고자 Optional<LoginUser>를 반환
            - "필수로 있어야할 컨트롤러의 매개변수를 사용자의 요청을 검증하여 넣어준다"는 ArgumentResolver의 역할이 퇴색됨
    - 인수테스트만으로 충분한가?
    - Controller에 대한 단위테스트를 진행하려고 했는데 문제가 있었음
        - 서비스가 Get 요청을 제외하고는 모두 회원이 로그인이 되어있어야 요청 가능하도록 설계했음
            - 그러다 보니, Controller 테스트를 위해 로그인을 해서 유효한 JWT 토큰을 발급 받고,
            - 이를 헤더에 넣어주어 MockMvc로 요청을 보냈어야 했음
            - 이렇게 보니 인수테스트와 다를게 없어보였음
                - PresentationLayer인 Controller를 테스트하는 것은 어쩌면 인수테스트에서 자연스레 검증된 것이라 생각도 들었음
            - HttpServletRequest등을 Mocking하는 것도 생각해봤는데... 너무 필요 이상의 Mocking이 아닌가 싶었음
    - Validation을 RequestDto와 Domain에서 어느정도로 해줘야 하는가?
        - Domain에서 validation 열심히 해주는 것을 Level1때 배움
            - Framework에 의존적이지 않은 도메인 설계가 가능했음
    
- __피드백 공유 및 코드가 개선된 포인트 공유__
    - Optional<LoginUser> 대신 다형성을 도입하여 LoginUser에 대한 해결
        - Member extends LoginUser, Anonymous extends LoginUser
    - 인수테스트 말고 도메인 테스트들도 작성하자
        - 기능의 추가/수정에 대한 빠른 피드백 받기 위함
    - 확장성이 필요하지 않다고 생각하는 어플리케이션에서는 적절히 책임 나눠서 Validation 진행
        - 앞단에서 진행한 Validation 믿고 뒤에꺼 쭉 진행
        - 어플리케이션의 성격과 중요성에 따라 적당히 타협을 보자
    - NamedParameterJdbcTemplate을 사용해볼것
        - 쿼리에 직접 어떤 key값이 대응될 지 지정해 줌
        ```java
        public void deleteById(Long id) {
            String sql = "delete from STATION where id = :id";
            namedParameterJdbcTemplate.update(sql, Collections.singletonMap("id", id));
        }
        ```
    - Line등의 도메인의 이름을 따로 객체로 포장하기
        - 원시값 포장
        - 분리될 만큼의 책임이 있다고 생각 안했음
            - 근데 오히려 분리하고 나니 Line의 로직들이 깔끔해져서 보기 좋음
            - 분리될 만큼의 책임 != 로직이 있어야 함
                - 유지보수확장에 유리한 코드를 짜기 위해 객체지향 설계 하는 거면, 잘게 나누는 것이 좋을 수도...?!
    - RequestDto에 primitive type이 있으면 누락시 default 0이 들어갈 수도
        - 애초에 Null을 받을 수 있는 래퍼 클래스를 사용하고 + `@NotNull` 및 `@PositiveOrZero`등의 Bean Validation 추가해주자
        
- __개선될 포인트__
    
