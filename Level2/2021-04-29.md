### 2021-04-29

## 배포하기 질문 답변
- __Qs. 브라우저에서 google.com를 요청할 때 통신 과정이 어떻게 이루어질까요?__
- __Qs. DDoS 공격에는 어떻게 대응하면 좋을까요?__
- __Qs. 현재 서버에서 몇개의 연결까지 가능한가요?__
- __Qs. 생성한 EC2의 스토리지 용량을 재부팅 없이, 늘리려면 어떻게 해야할까요?__

## 테코톡
- __Framework / Library / API__
    - Framework: 개발의 효율성을 높이기 위해 제공한 기본 뼈대, 집 짓기 평면도
        - 공통적인 개발 환경
        - 개발 범위가 정해져있음
        - 제어의 역전이 발생
    - Library: 개발자가 사용할 수 있는 API들을 종류나 목적에 따라 정의한 API 묶음, 재사용 가능한 코드의 집합
        - 개발에 필요한 것들을 모아놓은 저장소
        - 필요할 때 호출해서 사용
        - 흐름을 제어함
        - java.utils.math 뭐 이런거
    - API: 다른 프로그램이 제공하는 기능을 제어할 수 있는 인터페이스
        - 다른 프로그램과 연결 해주는 다리 역할
        - 구현이 아닌 제어를 담당
        - API 조합해 원하는 프로그램 만들 수 있음

- __ORM vs SQL Mapper vs JDBC__
    - Persistence
        - 데이터를 생성하는 프로그램이 종료되더라도 사라지지 읺는 데이터의 특성
    - JDBC만을 이용하여...!
        - JDBC: 자바에서 데이터베이스 접근하는 API
            - DBMS의 종류에 상관 없이 DB 작업을 처리
        - getConnection, preparedStatement, close
        - 간단한 SQL 실행해도 중복 많음
    - 이제 Persistence Framework...!
        - JDBC 프로그램의 복잡함, 번거로움 없이 간단한 작업만으로 DB와 연동되는 시스템 빠르게 개발
        - SQL Mapper와 ORM으로 나뉨!
    - SQL Mapper (Persistence Framework)
        - 객체와 SQL문을 매핑해서, SQL의 질의결과와 객체의 필드를 매핑시켜 객체화 시킴
        - Spring JDBC template
        - 나머지는 알아서 JDBC 템플릿이 처리
        - MyBatis
            - 반복적인 JDBC 단순화
            - SQL 쿼리를 XML에 작성하여 코드와 SQL 분리
            - interface 두고, XML로 쿼리 작성
            - Dao와 SQL 분리하여 코드의 간결성 및 유지보수성 향상 (관심사 분리)
    - 하지만 위에 두개 문제점
        - 특정 DB에 종속적으로 사용하게 됨
        - 테이블 필드가 변경시, 이와 관련된 모든 Dao의 SQL문, 객체의 필드 등을 수정해야 함
        - SQL 의존적인 개발
            - 비즈니스 로직보다 DB 접근 로직에 더 집중
        - 객체 지향 <--> 관계형 DB 
            - 설계 잘못됐나...?!
            - 관계형 DB와 객체간의 패러다임 불일치
            - 객체지향 (추상화, 상속, 다형성)
            - RDB (데이터 중심 구조)
    - ORM
        - 객체와 관계형 DB를 매핑
        - SQL 자동을 생성, 개발자의 불편 없이 구현
        - JPA!
            - 자바 진영의 ORM API 표준 명세
            - Hybernate가 이를 구현한 프레임워크
        - 패러다임 불일치 JPA가 해결!
            - 상속
                - RDB는 객체의 상속 개념이 읎다
            - 연관관계
                - 객체는 참조를 통해 다른 객체와 연관
                - 테이블은 외래키를 사용해 다른 테이블과 연관
            - 객체 그래프 탐색
        - 장점
            - 패러다임 불일치 문제 해결
            - 생산성
            - 데이터 접근 추상화, 벤더 독립성
            - 유지보수
        - 단점
            - 복잡한 쿼리 사용이 어려움
        - 도메인과 비즈니스 로직에 더 집중할 수 있음
                
- __인텔리제이 디버깅__
    1. Debug 모드로 실행
        - breakpoint를 잡아서 실행하자
        - variables에 지역 스코프 변수 차곡차곡 쌓임
    2. Resume
        - 프로그램 정지했는데, 다음 브레이크 포인트로 넘어가자~
    3. Step Over
        - 다음 줄로 넘어가자~
    4. Step Into
        - 브레이크 포인트 안에서 실행되는 메서드
            - new DaoFactory() => 자 이제 그 생성로직안으로 들어가자~
            - 찾고자 하는 흐름을 안으로 stack 쌓아가면서 들어가자~
    5. Step Out
        - Step in으로 들어갔던 거 실행 시키고 나오자~
    6. Run to Cursor
        - 내 커서가 있는 곳으로 넘어가세요!
        - 브레이크 포인트 찍는 효과
    7. Condition
        - 브레이크 포인트 우클릭 Condition 설정해서 for문 같은거 제어시킬 수 있어
            - for문 50개 중에서 32번째 항목
            - i == 32 인 경우!
            - 다 돌고 32번 째 딱 들어감
    8. Evaluate
        - alt+F8
        - Expression ==> 현재의 상태들을 물어볼 수 있음 오호!
            - users.size(); 같은거 
            - 해당 스코프에 적용
        - 실제로 Expression으로 물어본 코드는 정말 실행됨
            - users.add() 이런거 하면 ㄹㅇ 테스트 코드에 추가된다는 점
        - shift+enter로 여러 코드 쓸수있게 해줌
    - 제어의 역전으로 인해 외부 라이브러리로 브레이크 포인트가 넘어갈때 있음
        - 뇌절함
        - evalutate를 통해 에러 로직 찾고, 어디서 멈춰줄지 한번 더 확인해보자!