### 2021-04-30

## Mocking
- *참고: https://jojoldu.tistory.com/226*
- __문제점__
    - 통합 테스트 (하나의 Service 메서드 단위로 테스트) 진행
        - 여러 레파지토리, 비즈니스 로직이 함께 있어 애로사항 많이 발생
            - 불필요한 데이터 생성
            - 테스트 범위 넓어져
            - 피드백 slow
            - 상황 설정이 너무 장황함
                - GIVEN이 너무 많아져서, when then에 집중 X
                - 실제 테스트 대상과는 무관한 객체와 필드가 너무 많음
                - 하나의 테스트를 위해 필요한 주변 코드가 너무 많다!
                
- __해결 방법__
    - 테스트 코드를 주변 코드와 격리해야함
    - "테스트 더블": 목적에 따라 비슷한 듯 하면서도 다른 객체를 사용하는 것
        - 테스트 대상 코드 격리
        - 테스트 속도 개선
        - 예측 불가능한 실행 요소 제거
        - 특수 상황 테스트 가능
        - 감춰진 정보 확인 가능

- __@MockBean__
    - *참고: https://github.com/mockito/mockito/wiki/Mockito-features-in-Korean*
    - 기존에 사용되던 Bean의 껍데기만 가져오고, 내부의 구현 부분은 모두 사용자에게 위임
        - 해당 Bean으 어떤 메서드가 어떤 값이 입력되면 어떤 값이 리턴될지는 개발자가 조작 가능!!!!
        - 다음과 같이 chessService의 해당 로직의 참 조건을 지정해줘서, chessService 로직에 의존하는 Controller 테스트를 할 수 있었다!
        ```java
        @MockBean
        private ChessService chessService;
        
        @Test
        void postLogin() throws Exception {
            Mockito.when(chessService.validateUser("test", "test")).thenReturn(true);
            mockMvc.perform(post("/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content("{\"id\" : \"" + "test" + "\"" + ", " +
                            "\"password\" : \"" + "test" + "\"" +
                            "}"))
                    .andExpect(status().isOk());
        }
        ```

## 토비의 스프링 1주차 
- __인상깊던 구절__
    - 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이 스프링의 핵심 철학이다
    - 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다. 
        - 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는데 의미가 있다. 
        - 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것
    - 이런 문제의 근본적인 원인은 UserDao가 바뀔 수 있는 정보, 즉 DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다
        - 따라서 UserDao는 DB 커넥션을 가져오는 구체적인 방법에 종속되어 버린다
    - 가장 좋은 해결책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어 주는 것
    - 클래스 사이에 관계가 만들어진다는 것은, 클래스가 아니라, 오브젝트와 오브젝트 사이의 관계를 설정해 줘야 한다는 것
        - 오브젝트 사이의 관계가 만들어질라면 만들어진 오브젝트가 있어야 함
            - 직접 오브젝트 만드는 법도 있지만,
            - 외부에서 만들어 준 것을 가져오는 방법도 있다!
        - 단지 오브젝트 사이에 다이내믹한 관계(런타임 관계)가 만들어 지는 것
    - 팩토리: 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것
        - 오브젝트 "생성"과 오브젝트 "사용"의 역할/책임 분리!
    
- __디자인 패턴__
    - 템플릿 메서드 패턴
        - 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용
            - 변하지 않는 기능 -> 슈퍼클래스
            - 자주 변경되며 확장할 기능 -> 서브클래스
        - 서브클래스에서 추상 메서드 / protected 메서드를 오버라이딩 하여 필요에 맞게 사용
    - 팩토리 메서드 패턴
        - 서브 클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 메서드를 정의했음
        - 이 방식을 통해 오브젝트 생성 방법을 슈퍼클래스의 코드에서 독립 시키는 것
            
- __제어의 역전__
    - 모든 제어권한을 다른 대상에게 위임
        - 오브젝트가 자신이 사용할 오브젝트 스스로 선택 X, 생성 X
        - 자신도 어디서 어떻게 사용되는지 모름
        - 기능만 구현해 놓으면, 필요한 클래스에서 호출해서 사용
    - 실습에서 관심 분리, 책임 나누고, 확장 가능한 구조로 만들기 위해 "팩토리" 만든 것이 제어의 역전의 예시
    - Spring은 IoC를 극한으로 적용하고 있는 프레임워크!