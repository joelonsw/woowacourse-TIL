### 2021-05-19

## CORS
- *참고 1: https://www.youtube.com/watch?v=yTzAjidyyqs*
- *참고 2: https://developer.mozilla.org/ko/docs/Web/HTTP/CORS*
- __개요__
    - Cross-Origin Resource Sharing
        - 교차 출처 요청 및 데이터 전송!
    - 추가 HTTP 헤더를 사용해서, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 **접근할 수 있는 권한을** 부여하도록 브라우저에서 알려줌
        - 리소스가 자신의 출처와 다를 경우 교차 출처 HTTP 요청을 실행
    - fetch API는 "동일 출처 정책"을 따름
        - 자신의 출처와 동일한 리소스만을 불러올 수 있음
        - 다른 출처의 리소스를 불러오려면 "올바른 CORS 헤더 포함한 응답"을 반환해야 함
    - 원래 예전에는 브라우저에서 다른 URL을 가진 서버에 자원 요청을 하지 않았었어...
        - 그게 위험하다고 생각했거든
        - 근데 웹이 너무 발전하면서 프론트/백을 각각의 URL에 배치하면서 문제가 발생한거야

- __CORS를 사용하는 요청__
    1. XMLHttpRequest / Fetch API
    2. CSS 내 @font-face에서 교차 도메인 폰트
    3. WebGL 텍스쳐
    4. drawImage()를 사용해 그린 이미지/비디오
    5. 이미지 추출 CSS shapes

- __기능적 개요__
    - CORS는 허용된 출처를 **"서버에서 설명할 수 있는 새로운 HTTP 헤더를 추가"**함으로써, 웹 브라우저에서 해당 정보를 읽기를 지원하도록 동작
    - 서버 데이터에 side effect를 일으킬 수 있는 HTTP 요청 메서드 *(GET을 제외한 메서드)* 에 대해서는...
        - OPTIONS 메서드로 **preflight**를 하여 지원하는 메서드 요청, 서버의 허가가 떨어지면 실제 요청을 보내도록 함

- __Preflight__
    - simple request가 아닌 것들은 preflight 요청을 보내 **실제 요청이 안전한지** 확인
        - 데이터를 조작하는 (POST/PUT/DELETE) request를 아무곳에서나 받으면 안되자나?
    - OPTIONS 요청을 보내 preflight request/response를 받음
    - 이후 preflight request가 완료되면 실제 요청을 전송
    - 요청 예시
        ```
        --------------Preflight--------------
        OPTIONS /doc HTTP/1.1
        Origin: http://foo.example
        Access-Control-Request-Method: POST
        Access-Control-Request-Headers: X-PINGOTHER, Content-Type
        
        HTTP/1.1 200 OK
        Access-Control-Allow-Origin: http://foo.example
        Access-Control-Allow-Methods: POST, GET, OPTIONS
        Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
        Access-Control-Max-Age: 86400
        -------------------------------------
        
        ---------------Request---------------
        POST /doc HTTP/1.1
        X-PINGOTHER: pingpong
        Content-Type: text/xml; charset=UTF-8
        Origin: http://foo.example
        Access-Control-Request-Method: POST
        Access-Control-Request-Headers: X-PINGOTHER, Content-Type
        
        HTTP/1.1 200 OK
        Access-Control-Allow-Origin: http://foo.example
        -------------------------------------
        ```

- __HTTP 요청 헤더__
    - **Origin** : cross-site 접근 요청 or preflight request의 출처
    - **Access-Control-Request-Method** : 실제 요청에서 어떤 HTTP 메서드를 사용할 지 서버에게 알림
    - **Access-Control-Request-Headers** : 실제 요청에서 어떤 HTTP 헤더를 사용할지 서버에게 알리기 위해 preflight에 포함 
    
- __HTTP 응답 헤더__
    - **Access-Control-Allow-Origin** : 단일 출처를 지정하여 해당 출처가 리소스에 접근하도록 허용
    - **Access-Control-Max-Age** : preflight request 요청 결과를 캐시할 수 있는 시간을 나타냄
    - **Access-Control-Allow-Credentials** : credentials 플래그가 true일 때 요청에 대한 응답을 표시할 수 있는지
    - **Access-Control-Allow-Methods** : 리소스에 접근할 때 허용하는 메서드 지정
    - **Access-Control-Allow-Headers** : 실제 요청시 사용할 수 있는 HTTP 헤더 나타냄

## Spring으로 CORS 다루기
- *출처: https://spring.io/blog/2015/06/08/cors-support-in-spring-framework*
- __개요__
    - 보안적인 이슈로 인해서 현재 자신의 origin에서 벗어난 AJAX 요청은 금지되어 있다. 
    - Spring MVC는 하이레벨에서 설정을 다룰 수 있도록 지원한다. 

- __Controller에서 CORS configuration__ 
    - `@CrossOrigin`을 붙여 CORS를 허락해주도록 할 수 있음
        - 필요한 메서드에 추가하거나, 컨트롤러 통채로 등록하거나
        ```java
        @CrossOrigin(origins = "http://domain2.com", maxAge = 3600)
        @RestController
        @RequestMapping("/account")
        public class AccountController {
        
            @GetMapping("/{id}")
            public Account retrieve(@PathVariable Long id) {
                // ...
            }
        }
        ```
    - Spring Security를 사용중이라면, Spring Security level에서 CORS 사용토록 설정하자
        ```java
        @EnableWebSecurity
        public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
        
            @Override
            protected void configure(HttpSecurity http) throws Exception {
                http.cors().and()...
            }
        }
        ```

- __전역에서 CORS configuration__
    - JavaConfig에서 다음과 같이 CORS를 활성화 시켜줄 수 있음
        ```java
        @Configuration
        @EnableWebMvc
        public class WebConfig extends WebMvcConfigurerAdapter {
        
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**");
            }
        }
        ```
    - 다음과 같이 특정 필드들에 대해 설정을 활성화 시킬 수 있음
        ```java
        @Override
        public void addCorsMappings(CorsRegistry registry) {
            registry.addMapping("/api/**")
                .allowedOrigins("http://domain2.com")
                .allowedMethods("PUT", "DELETE")
                    .allowedHeaders("header1", "header2", "header3")
                .exposedHeaders("header1", "header2")
                .allowCredentials(false).maxAge(3600);
        }
        ```
    - **addMapping** : CORS를 적용할 URL 패턴 정의
    - **allowedOrigins** : 자원 공유를 허락할 요청 주소(Origin) 지정 가능
    - **allowedMethods** : 허용할 HTTP method를 지정할 수 있음
    - **maxAge** : 원하는 시간 만큼 preflight 리퀘스트 캐싱해둠 (이 시간 동안은 preflight 검증 안해도 됨!)
    
- __동작 원리__
    - CORS 요청 *(preflight 요청 포함)* 은 자동으로 등록된 HandlerMapping으로 전파
    - CorsProcessor 구현체에서 해당 요청을 넘겨받아 CORS 응답 헤더를 작성해줌
    - CorsConfiguration 에서 CORS request들이 프로세싱 되어야 하는지 명시할 수 있음
        - 헤더 작성, 메서드 등
    
## JWT에 대해서


