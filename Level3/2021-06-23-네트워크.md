### 2021-06-23 네트워크

## 소켓
- **소켓이 뭔가요?**
    - 소켓은 서로 다른 프로세스들이 네트워크를 거쳐 통신할 수 있도록 지원 합니다. 
    - 소켓은 "사용하는 프로토콜/서버의 IP/서버의 Port/클라이언트의 IP/클라이언트의 PORT"로 식별
- **소켓은 어떤 Layer 소속인가요?**
    - Application Layer와 Transport Layer 사이에 위치함
    - Transport Layer 위에서 프로토콜 제어를 위한 코드를 제공 
        - Transport layer에서 사용할 TCP/UDP
        - 클라-서버의 IP:PORT를 지정
- **소켓의 연결 과정을 설명해주세요**
    - 클라이언트는...
        - socket() 함수로 소켓 통신을 위해 TCP/UDP 타입 지정
        - connect() 함수로 서버의 IP:PORT 지정
        - write()&read() 함수로 데이터를 보내고 읽고
        - close() 함수로 연결 종료하고
    - 서버는...
        - socket() 함수로 소켓 통신을 위해 TCP/UDP 타입 지정
        - bind() 함수로 소켓이 지정된 Port Number를 사용할 것이라 OS에 요청
        - listen() 함수로 서버 소켓에 클라이언트 요청 대기
        - accept() 연결 받아들여 소켓 간 연결 수립
            - 이때 listen() 하고 있던 소켓 말고, 
            - 새로운 소켓으로 연결이 수립
        - write()&read() 함수로 데이터를 보내고 읽고
        - close() 함수로 연결 종료하고
- **HTTP 요청도 소켓에 기반한 것인가요?**
    - *참고: https://stackoverflow.com/questions/38650547/is-http-based-on-socket*
    - HTTP는 Application Layer에, Socket은 Application Layer와 Transport Layer 사이에 구현되어 있어요. 
    - 따라서 HTTP 요청을 보낼때 Socket을 사용해서 보내도록 구현할 수 있어요. 
        - 클라이언트와 서버는 결국 다른 프로세스간의 통신이 필요한 것이니까요. 
    - 하지만 패킷을 네트워크를 통해 전송할 수 있다면 꼭 소켓을 쓰지 않아도 될 것이에요. 

## 접근 통제
- **배스쳔 서버를 어떻게 구축했나요?**
    - 서비스용 서버에 22번 포트는 배스쳔의 private IP로만 접근 가능하도록 했다. 
        - 사실 미션 자체에선 보안 그룹은 못건드렸지만...
        - 배스쳔과 서비스를 둘다 AWS의 인스턴스로 구성하여, 내부에서만 접근할 수 있도록 private ip를 사용했다. 
    - 나 --PORT22(pem키)--> 배스쳔 --PORT22(rsaKEY)--> 서비스
- **배스쳔 서버가 왜 필요할까요?**
    - 22번 포트는 SSH 연결을 통해 직접 서비스 컴퓨터의 쉘에 접근합니다. 
        - 따라서 해당 포트로의 접근을 잘 막아둬야 합니다. 
    - 따라서 특정 인스턴스에서만 22번 포트로의 접근을 허용해둡니다. 
        - 이렇게 되면 다른 컴퓨터에서의 22번 포트 접근 모두 차단됩니다. 

## OSI 7 Layer
- *참고: https://www.youtube.com/watch?v=1pfTxp25MA8&t=1764s*
- **배경 지식**
    - 스위치를 통해 같은 네트워크에 속한 사람들끼리 서로에게 필요한 정보를 보내고 통신 가능
    - 라우터를 통해 서로 다른 네트워크에 속한 스위치들을 연결 (라우터 == 공유기)
    - 인터넷을 통해 전 세계 컴퓨터들을 연결한 것
    - 현대의 인터넷은 OSI 모델이 아닌, TCP/IP 모델을 따르고 있음
        - TCP/IP가 이겼어
        - TCP/IP는 OSI 모델의 Application, Presentation, Session을 뭉뜽그려 Application Layer
- **Physical Layer**
    - 0, 1의 나열을 아날로그 신호로 변경해 전선으로 흘려보냄
    - 아날로그 신호를 0, 1의 나열로 해석해
    - 물리적으로 연결된 두 컴퓨터가 0, 1의 나열 주고 받게 해주는 모듈
    - PHY 칩
        - 하드웨어적으로 구현되어 있음
- **Data Link Layer**
    - 같은 네트워크(스위치로 연결)에 있는 여러 대의 컴퓨터들이 데이터를 주고 받기 위해 필요한 모듈
    - Framing을 통해 정보의 시작점과 종점을 알려줌
        - ex. 시작점 1111, 종점 0000
            - 1111[data]0000 [] 안에가 정보
    - LAN 카드에 구현
        - 하드웨어적으로 구현되어 있음
- **Network Layer**
    - 이제 목적지의 IP를 붙인 data를 패킷으로 포장
        - ex. 1111<\IP:12.23.34.56-[data]>0000
    - 수많은 네트워크의 연결로 이루어지는 inter-network 속에서
    - 어딘가에 있는 목적지 컴퓨터로 데이터를 전송하기 위해, 
        - ip 주소를 이용해 길을 찾고 (라우팅)
        - 자신 다음의 라우터에게 데이터를 넘겨주는 것 (포워딩)
    - OS 커널에 SW적으로 구현됨
    - 이제 전 세계 컴퓨터가 데이터를 주고 받을 수 있게 되었다!
- **Transport Layer**
    - 우선 데이터는 받았는데,,, 어떤 프로세스한테 요청이 온거지??
    - 이제 목적지의 Port를 붙인 data를 패킷으로 포장
        - ex. 1111<\IP:12.23.34.56{PORT:80-[data]}>0000
    - Port 번호를 사용하여
    - 도착지 컴퓨터의 최종 도착지인 프로세스에 까지
    - 데이터가 도달하게 하는 모듈
    - OS 커널에 SW적으로 구현됨
- **Application Layer**
    - TCP/IP 소켓 프로그래밍
        - OS의 Transport Layer에서 제공하는 API를 기반으로 통신 가능한 프로그램 만드는 것
    - 이제 목적지에 보낼 data를 포장하자
        - ex. 1111<\IP:12.23.34.56{PORT:80-[HTTP MESSAGE]}>0000
