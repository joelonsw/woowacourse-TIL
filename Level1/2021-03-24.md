### 2021-03-24

## 90년생 HTML
- 참고: https://www.youtube.com/watch?v=cANdjq3yr1M&t=7s
- __스위스 태생__
    - CERN 물리학 연구소에서 1990년에 WEB 탄생 *(by Tim Berners-Lee)*

- __이후 웹의 폭발적 성장__
    - HTML / CSS / JS
    - 정보 나타냄 / 정보 꾸며줌 / 정보를 움직이게 함

- __HTML 약속__
    - HyperText Markup Language
        - 하이퍼텍스트(링크)를 중요한 특징으로 가지는 마크업 형식의 언어
    - 정보를 태그로 나타내기!
    ``` HTML
    <h1> I am a web developer </h1>
    ```
    - <h1>: 여는 태그, </h1>: 닫는 태그
    - I am ~: 콘텐츠
    - 전체: 엘리먼트
    
    - 태그 150개 이상... 자주 쓰는 것만 알아보고, 나머진 찾아쓰자

## DOM
- __필요성__
    - JS를 통해 html의 데이터를 가져올 수 있음
    - 웹페이지에 보여지는 데이터를 변경할 수 있음
    - 인터랙티브한 웹 어플리케이션 만들 수 있음
    - 동적인 기능이 있는 웹어플리케이션을 만들어보자!

- __정의__
    - Document Object Model의 약자
    - 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공해, 문서 구조/스타일/내용을 변경할 수 있게 한다
    
- __DOM API 사용하기__
    - 엘리먼트 하나 가져오기
        - getElement, querySelector
            - getElementById
            - querySelector
    - 엘리먼트 여러 개 가져오기 (HTML Collection 반환)
        - getElements, querySelectorAll
            - getElementsByTagName
            - getElementsByClassName
            - querySelectorAll

- __정리__
    - DOM은 HTML을 위한 API로, HTML을 "탐색"할 수 있고, 구조를 "변경"할 수 있음

## BOM
- __필요성__
    - 유저에게 경고창 띄워주기
    - 유저의 yes/no 선택에 따른 응답 보여주고 싶은 경우
    - 유저가 브라우저 나갈 때 진짜 나갈건지 물어보고 싶은 경우
    - 유저가 접속한 환경을 알고 싶은 경우
    - 현재 url 위치, 접속 history를 알고 싶은 경우!

- __정의__
    - BOM은 웹 브라우저 환경의 다양한 기능을 객체처럼 다루는 모델
    - 웹 브라우저의 버튼, URL 주소 입력 창, 타이틀 바 등 웹브라우저 일부분을 제어

- __대표 BOM__
    - window: 브라우저 창 객체
    - screen: 사용자 환경의 디스플레이 정보 객체
    - location: 현재 페이지의 url을 다루는 객체
    - navigator: 브라우저 환경 정보 객체
    - history: 현재 브라우저가 접근했던 URL history
    
- __정리__
    - BOM은 웹 브라우저의 기능을 객체처럼 다루는 모델
    - BOM의 API 활용하면, UX 올라감
    
## DOM & BOM 테코톡
- __DOM__
    - JS가 HTML 어케아누?... DOM을 통해!__
    - 문서에 대한 모든 내용을 담고 있음
    - __"HTML 요소간의 부자 관계를 반영하여 트리 구조로 구성한 것"__
- __DOM API를 통해 노드 취득__
    - getElement~, querySelect~        
    - 여러개 라면 HTMLCollection, NodeList 등을 반환
        - 유사 배열... 배열 변환 후 사용을 권장
- __DOM API를 통해 노드 추가__
    - innerHTML: 장) 쉬움, 단) 한번만 삽입할 것
    - insertAdjacentHTML: 장) 기존요소 제거 X, 단) 크로스 사이트 스크립팅 공격에 취약
    - appendChild: 장) 보안이슈 읎음 단) 새로운 자식 노드 생성 필수
- __렌더링 과정__
    - HTML 순차적 탐색하면서 DOM 생성해나감
        - link CSS 만남... CSSOM 생성함
    - DOM + CSSOM 합쳐서 렌더 트리 만듦
        - Script JS 만남... 렌더링 엔진 -> JS 엔진으로 제어권 넘김
        - 만약 JS에서 DOM / CSSOM 건드리면, reflow, repaint 불가피 
    - 질문!
        - CSS 상단에 있는 이유?
            - 외부 스타일 시트 최대한 빠르게 다운 받기 위해
        - Script 하단에 있는 이유?
            - HTML 파서는 script 태그를 만나면 파싱 멈추고 스크립트 읽기에 로딩 늦어짐
            - 생성안된 DOM 읽거나 조작하는거 불가능해서 오류 발생할 수 있음
- __렌더링 문제점__
    - 동적 UI 관리 약함... 성능 이슈
        - DOM은 빠른데, css재구성/리페인트가 오래걸림
    - SPA에서 비효율적
- __Virtual DOM__
    - 바뀐 부분만 실제 DOM에 적용
    - 불필요한 렌더링 횟수 줄임
- __BOM__
    - 웹 브라우저 환경의 다양한 기능을 객체처럼 다룸
    - DOM은 BOM에 포함됨
    - window
        - document
        - history
        - location
        - navigator
        - screen

## Event
- __필요성__
    - Interactive 한 사용자 경험!

- __정의__
    - 웹 탐색과정에서 사용자가 ~했을 때를 담당
    - ~했을 때에 대한 이벤트를 다루도록 한다!
    
- __종류__
    - 1. 사용자 인터페이스 이벤트
        - load: 웹 페이지 로드 되었을 때
        - unload: 새로운 페이지르 요청했을 때
        - error: 브라우저가 JS 오류를 만났거나, 요청한 자원이 없을 때
        - resize: 브라우저 창의 크기 조정했을 때
        - scroll: 사용자가 페이지 위아래로 스크롤할 때

    - 2. 키보드 이벤트
        - keydown: 사용자가 키 처음 눌렀을 때
        - keyup: 사용자가 키를 뗄 때
        - keypress: 사용자가 키 누르고 뗴어서 문자 화면에 표시 될 떄
        
    - 3. 마우스 이벤트 
        - click: 마우스 클릭했을 때
        - dblclick: 마우스 더블 클릭했을 때
        - mousedown: 마우스 누르고 있을 때
        - mouseup: 마우스 뗄 때
        - mousemove: 마우스 움직일 때
        - mouseover: 요소 위로 마우스를 움직였을 때
        - mouseout: 요소 바깥으로 마우스 움직였을 때

    - 4. focus와 blur
        - link, form에서 포커스를 줄 수 있음
        - 사용자가 form의 요소들과 상호작용(도움말/피드백 등)
        - 유효성 검사 수행 등
        - focus: 마우스를 클릭했을 때
        - blur: 마우스를 더블클릭했을 때
        - focusin: 마우스 누르고 있을 떄
        - focusout: 요소에서 마우스 누르고 있던거 뗄 때
        
- __이벤트 핸들러__
    - element.addEventListener(이벤트, 코드[, options]);
    - 매개변수를 전달 하고자 하면, 다음과 같은 익명함수를 이용하자
    ``` JS
    $stationAddButton.addEventListener('blur', function() {
        onAddStationHandler(name);
    })
    ```
  
- __이벤트 위임__
    - 이벤트 많다 == 페이지 실행 속도 느리다
    - 효율적 이벤트 관리 위해, 자식 요소를 포함할 수 있는 요소에 이벤트 핸들러를 지정하고, 이벤트의 흐름을 이용해 다룰 수 있음
    - 장점
        - 동적으로 추가되는 "새로운" 요소에도 동작
        - 코드가 간결
    - 예시
        ``` HTML
        <ul id="parent-list">
            <li id="item1">Item 1</li>
            <li id="item2">Item 2</li>
            <li id="item3">Item 3</li>
        </ul>        
        ```
        ``` JS
        document.getElementById("parent-list").addEventListener("click", function(e) {
            if (e.target && e.target.nodeName == "LI") {
                console.log(`List item ${e.target.id} was clicked!`);
            }
        });
        ```
      
## hashCode와 equals의 동치성 보장
- 리뷰어 미립과의 대화!
- 문제 상황: 나의 Pawn 클래스에서 오버라이딩한 hashCode와 equals 메서드가 동치성을 보장하지 않는다?!
    - 나는 하는 줄 알았는데...
    - 현재 코드
    ``` Java
    @Override
    public int hashCode() {
      return PAWN_UNICODE_DECIMAL * direction;
    }
  
    @Override
    public boolean equals(Object obj) {
      if (obj == null) return false;
      if (this == obj) return true;
      return getClass() == obj.getClass();
    }
    ```
- __1. hashCode 는 같지만 equals 는 같지 않은 케이스는 발생 할 수 없을까요?__
    - 발생할 수 있어요.  
      현재 Pawn 클래스의 모든 인스턴스는 hashCode로 9817을 가지고 있어요.  
      Integer 클래스 같은 경우, 정수값 그 자체가 hashCode로 사용되어요.  
      만약 다음과 같은 코드를 작성하면, 두 객체의 hashCode의 값은 같아요.  
    
    ![facade](../image/hashCode_equals_2021_03_24.png)

    - 다만 Integer객체와 Pawn 객체의 equals는 달라요.  
      HashSet에 둘이 각각 저장된 것이 그것의 반증이에요.  
      객체를 HashSet에 넣을 때 hashCode/equals를 비교하여 같다면 같은 키값으로 인지하는데,  
      해당 테스트 코드에서는 둘을 다른 객체로 인지했으니까요.  

- __2. 근데 hash 값과 eqauls 가 다른 방식으로 구현되어 있어 수정 중 둘의 동치성이 깨진다면 hashSet에서 어떤 문제가 발생할까요?__
    - hashSet은 hash값과 equals가 같은경우, 같은 Key값으로 인지해요.  
      만약 둘 중 하나가 다르다면, hashSet/Map에 key값이 각각 저장될 것이에요.  
      각각 저장된 두개의 Key가 사실 같은 객체였어야 한다면, 다음과 같은 문제가 발생해요.  
      고유한 Key값에 대응하는 Value를 저장하고 싶어 hashMap을 사용하는데, 이것이 보장이 안될 것이에요.  

- __3. 또한 hash 값의 중복이 발생한다면 또 어떻게 될까요?__
    - 우선 hash 값의 중복이 발생하면, hash 충돌이 일어나요.  
      hash 충돌이 일어나면, 해당 hash 값을 저장하는 버킷에 하나 이상의 데이터가 저장되어야 해요.  
      만약 hash 충돌이 너무 자주일어나, 하나의 버킷에 주렁주렁 데이터가 저장된다면,  
      O(1)의 속도를 보장하기 때문에 쓰려고 했던 hashMap/hashSet의 성능을 매우 저하시킬 것이에요.  

    - https://papimon.tistory.com/74  
      얼마 전, HashMap/HashSet의 출력이 순서를 가지는 것 같아 공부를 하던 중 발견한 것들을 제 블로그에 정리했었어요.  
      이때 참고했던 포스팅이 https://d2.naver.com/helloworld/831311 이거였어요.  
      해당 포스팅에서는 hashCode가 충돌하는 데이터를 다음과 같이 처리한다고 명시했어요.  
      기존 Java 7까지는 hash 충돌이 발생한 버킷에 대해, LinkedList로 데이터를 이어 저장해요.  
      이는 탐색에 최악 O(N)의 시간복잡도를 가져요.  
      Java 8 부터는 RBtree를 통한 데이터 저장으로 최악 O(logN)의 시간복잡도를 가지게 했다고 이해했어요.  

- __이제 내 코드의 문제점!__
    - 현재 저의 Pawn의 hashCode, equals 오버라이딩 된 코드에요.  
      Pawn의 direction에 따라 다른 hashCode를 반환하는 대신,  
      equals는 그저 같은 클래스라면 동등성을 보장하도록 제가 코드를 작성해놨어요.  
      여기에서 제가 위에 정리한 문제들이 발생할 수 있을것 같아요!  
      
      ``` Java
      @Override
      public int hashCode() {
          return PAWN_UNICODE_DECIMAL * direction;
      }
      @Override
      public boolean equals(Object o) {
          if (this == o) return true;
          if (o == null || getClass() != o.getClass()) return false;
          Pawn pawn = (Pawn) o;
          return direction == pawn.direction;
      }
      ```
      
    - 해당 방식으로, direction이 같은 경우 동등성을 보장하도록 코드를 작성하는게,  
       hashCode와 equals의 동작을 동일하게 가져가는 방향이겠네요!

    - 미립의 답변!
        - 위처럼 사용자정의로 equals 과 hashCode 를 재정의하면 알 수 없는 사이드 이펙트가 발생 할 수 있기때문에 (사람이 하는 일이라 😭) 신중하게 접근하면 좋을 것 같아요

## 객체 생성을 캡슐화 하는 것
- 참고: https://velog.io/@ljinsk3/%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%9[…]EB%93%9C%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C  
체스에 필요한 팀 객체를 인스턴스화 하기 위해 나는 그동안 Team 클래스의 생성자를 통해 각 팀을 생성해주었다.  
``` Java
public Team(final PiecePosition piecePosition, final PieceCaptured pieceCaptured, final Score score) {
    this.piecePosition = piecePosition;
    this.pieceCaptured = pieceCaptured;
    this.score = score;
}
```
하지만 생각해보니까, 체스에는 블랙팀, 화이트팀만 있으면 된다.  
그러면 굳이 생성자를 열어두지 말고(물론 열어줘도 됨),  
BlackTeam을 만드는 정적 팩토리 메서드와 WhiteTeam을 만드는 정적 팩토리 메서드를 만들어 보는 것은 어떨까?  
``` Java
private Team(final PiecePosition piecePosition, final PieceCaptured pieceCaptured, final Score score) {
    this.piecePosition = piecePosition;
    this.pieceCaptured = pieceCaptured;
    this.score = score;
}
public static Team blackTeam() {
    return new Team(PiecePosition.initBlackPosition(), new PieceCaptured(), new Score());
}
public static Team whiteTeam() {
    return new Team(PiecePosition.initWhitePosition(), new PieceCaptured(), new Score());
}
```
즉, 생성자를 private으로 숨기고,  
blackTeam()이라는 정적 팩토리 메서드를 통해, 블랙팀에 필요한 정보를 담아 Team 객체를 생성하여 반환하고,  
whiteTeam()이라는 정적 팩토리 메서드를 통해, 화이트팀에 필요한 정보를 담아 Team 객체를 생성하여 반환하면,  
체스에 필요한 팀 생성의 역할을 Team 클래스가 완벽히 수행하면서 + 지정된 팀(블랙팀/화이트팀) 만 생성하도록 강제할 수 있다.  

해당 방식으로 코드를 리팩토링 했더니,  
Team 생성에 필요한 정보를 생성자를 통해 외부로 공개하지 않고,  
체스에 필요한 팀을 만드는 역할을 충분히 하게 되었다.  

## 사용할 객체를 캐싱해 둔다는 것

