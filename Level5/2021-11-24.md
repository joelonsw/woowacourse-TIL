### 2021-11-24

## 템플릿 메서드 패턴
- *참고 1: https://gmlwjd9405.github.io/2018/07/13/template-method-pattern.html*
- *참고 2: https://yaboong.github.io/design-pattern/2018/09/27/template-method-pattern/*
- **개념**
    - 변하지 않는 기능 : 슈퍼 클래스
    - 변경/확장될 기능 : 서브 클래스
    - 전체적으로는 동일하면서 부분적으로는 다른 구문으로 구성된 메서드의 코드 중복 최소화

- **예시**
    ```java
    public abstract class AbstractClass {
        protected abstract void hook1();
        protected abstract void hook2();

        public void templateMethod() {
            hook1();
            hook2();
        }
    }

    public class ConcreteClass extends AbstractClass {
        @Override
        protected void hook1() {
            System.out.println("hook1");
        }

        @Override
        protected void hook2() {
            System.out.println("hook2");
        }
    }

    public class TemplateMethodPatternClient {
        public static void main(String[] args) {
            AbstractClass abstractClass = new ConcreteClass();
            abstractClass.templateMethod();
        }
    }
    ```

## 템플릿 콜백 패턴
- *참고: https://multifrontgarden.tistory.com/101*
- **개념**
    - 전략 패턴과 템플릿 메서드 패턴의 혼합
    - 전략 패턴이 "클래스 레벨"에서의 확장이라면, 템플릿 메서드 패턴은 "메서드 레벨"에서의 확장
    - 외부에서 함수를 주입한다! (JS에서는 자연스러운 흐름)
        - 자바에서는 어쩔 수 없이 객체를 생성해야함
        - 난잡하게 하나하나 다 생성할 수는 없으니 '익명 내부 클래스' 로 쇼부
        - 함수형 인터페이스로 발전 가능함!

- **예시**
    ```java
    @FunctionalInterface
    interface Calculator {
        public int calculation(int num1, int num2);
    }

    public class CalculatorTemplate {
        public int templateMethod(int num1, int num2, Calculator c) {
            return c.calculation(num1, num2);
        }
    }

    public class Test {
        public static void main(String[] args) {
            CalculatorTemmplate ct = new CalculatorTemmplate();
            System.out.println(ct.templateMethod(5, 10, (num1, num2) -> num1 + num2));
            System.out.println(ct.templateMethod(5, 10, (num1, num2) -> num1 * num2));
        }
    }
    ```
