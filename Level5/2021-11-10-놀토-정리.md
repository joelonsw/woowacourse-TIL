### 2021-11-10 놀토 정리

## 놀토의 예외처리 전략
- **1. 어플리케이션에서 발생하는 최상단 예외를 NoltoException으로 정의**
    ```java
    @Getter
    public class NoltoException extends RuntimeException {
        private final HttpStatus httpStatus;
        private final ExceptionResponse body;
    
        public NoltoException(HttpStatus httpStatus, ErrorType errorType) {
            super(errorType.getMessage());
            this.httpStatus = httpStatus;
            this.body = new ExceptionResponse(errorType.getErrorCode(), errorType.getMessage());
        }
    }
    ```  

- **2. ExceptionResponse를 만들어서 Exception의 body로 errorCode와 message를 줄 수 있도록 설정**
    ```java
    @Getter
    public class ExceptionResponse {
        private String errorCode;
        private String message;
        
        public ExceptionResponse(String errorCode, String message) {
          this.errorCode = errorCode;
          this.message = message;
        }
        
        public static ExceptionResponse of(ErrorType errorType) {
          return new ExceptionResponse(errorType.getErrorCode(), errorType.getMessage());
        }
    }
    ```

- **3. NoltoException을 상속하여 Error_Status_Code를 담은 에러를 만듬**
    ```java
    public class InternalServerErrorException extends NoltoException {
        public static final HttpStatus INTERNAL_SERVER_ERROR = HttpStatus.INTERNAL_SERVER_ERROR;
    
        public InternalServerErrorException(ErrorType errorType) {
            super(INTERNAL_SERVER_ERROR, errorType);
        }
    }
    
    public class NotFoundException extends NoltoException {
        public static final HttpStatus NOT_FOUND = HttpStatus.NOT_FOUND;
    
        public NotFoundException(ErrorType errorType) {
            super(NOT_FOUND, errorType);
        }
    }
    ```

- **4. Enum으로 예외를 관리하기**
    - 예외 생성할 때 생성자로 해당 ErrorType을 넣어줘야함
    - 프론트와 합의함에 따라, errorCode
    ```java
    @Getter
    @RequiredArgsConstructor
    public enum ErrorType {
        DATA_BINDING_ERROR("common-001", "요청값이 잘못되었습니다."),
        INVALID_TOKEN("auth-001", "유효하지 않은 토큰입니다."),
        FEED_NOT_FOUND("feed-001", "존재하지 않는 피드입니다."),
        NOT_SUPPORTED_IMAGE("image-001", "지원하지 않는 이미지 입니다."),
        ALREADY_LIKED("like-001", "이미 좋아요 누른 글 입니다."),
        COMMENT_NOT_FOUND("comment-001", "존재하지 않는 댓글입니다."),
        ALREADY_EXIST_NICKNAME("member-001", "이미 존재하는 닉네임입니다."),
    
        private final String errorCode;
        private final String message;
    }
    ```
  
- **5. ControllerAdvice에서 처리해주기**
    ```java
    @ExceptionHandler(NoltoException.class)
    public ResponseEntity<ExceptionResponse> handleNoltoException(NoltoException e) {
        log.info(e.getBody().getMessage());
        return ResponseEntity.status(e.getHttpStatus()).body(e.getBody());
    }
    ```

## 놀토의 테스트 전략
- 테스트 코드에 왜 `@Transactional`을 쓴거냐?

## 놀토 인프라
1. Why replication?
2. Why load-balancing?

## 놀토 JPA
1. Persist + All로도 안사라짐
2. N+1
    - fetch
    - batchSize
3. 트랜잭션 At 테스트코드 XX
4. OrphanRemoval, CascadeOption
