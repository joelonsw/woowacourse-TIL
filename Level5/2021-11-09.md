### 2021-11-09

## JPA 순환 참조
- *참고: https://velog.io/@chjh121/JPA-%EC%88%9C%ED%99%98-%EC%B0%B8%EC%A1%B0*
- **문제 상황**
    - 엔티티의 양방향 매핑이 되어있는 상황
    - 해당 엔티티를 직렬화하는 과정에서 무한 참조 발생
    ```java
    @Entity
    public class User {
    
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        private String email;
    
        private String password;
    
        @OneToMany(fetch = FetchType.LAZY, mappedBy = "user")
        private List<Post> postList;
    }
    
    @Entity
    public class Post {
    
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String title;
    
        private String content;
    
        private String writer;
    
        @ManyToOne(fetch = FetchType.LAZY)
        private User user;
    }
    ```

- **직렬화 과정**
    - Jackson에서 객체를 직렬화할 때 문제가 발생함!
    1. 요청한 Post 객체 직렬화
    2. Post Entity내의 User를 직렬화
    3. User Entity내의 `List<Post>`를 직렬화

- **해결 방법**
    - `@JsonIgnore` : 해당 필드를 직렬화 대상에서 제거
    - User에 `@JsonManagedReference`를, Post에 `@JsonBackReference`를 추가해주기
    - DTO를 사용하기 <= 추천

## Easy Deploy 로그인 복습하기 (Session)
- **회원가입 + 로그인 과정**
    1. 사용자가 구글 로그인 버튼 누르면 OAuth 로그인 창으로 리다이렉트 `GET /login/google`
    2. 사용자가 로그인 하면, 지정했던 리다이렉트 URL로 GET 요청을 구글에서 코드를 곁들여 보냄 `GET /login/oauth/google`
    3. 받은 Code를 가지고, Google로 부터 AccessToken을 발급받음
    4. 발급받은 AccessToken을 가지고, Google에서 User 정보를 조회해옴
    5. User 정보를 저장하고, 유니크한 SocialId를 반환함
    6. "socialId"를 Key로, socialId를 Value로 Session을 만듦
        ```java
        @GetMapping("/login/oauth/{social}")
        public String loginWithSocial(@PathVariable String social, @RequestParam String code, HttpServletRequest request) {
            String socialId = loginService.loginWithSocial(social, code);
            HttpSession session = request.getSession();
            session.setAttribute("socialId", socialId);
            return "redirect:/";
        }
        ```
    7. 메인페이지로 리다이렉트

- **로그인 이후 유저 권한으로 서비스 사용**
    - ArgumentResolver에서 다음과 같이, 세션을 통해 socialId를 가져옴
        ```java
        @Override
        public User resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
                                    NativeWebRequest webRequest, WebDataBinderFactory binderFactory) {
            HttpServletRequest request = (HttpServletRequest) webRequest.getNativeRequest();
            HttpSession session = request.getSession();
            Object socialId = session.getAttribute("socialId");
            if (Objects.isNull(socialId)) {
                throw new NotLoggedInException("로그인 사용자가 없습니다.");
            }
            return userRepository.findBySocialId((String)socialId)
                    .orElseThrow(NotLoggedInException::new);
        }
        ```
    - 조회한 User를 Controller의 파라미터로 넣어주고 사용
    
- **같은 socialId로 어떻게 특정 socialId를 가져온거야?**
    - 결국 Session도 쿠키의 일종이잖아요? 다음과 같이 반환되잖아요?
        - JSESSIONID = 고유한값 
    - 사용자의 Http Request를 보면 Cookie: JESSIONID=고유한값 이렇게 요청이 갈거란 말이죠
    - HttpSessions 라는 백엔드 전반에서 공유하고 있는 저장소에 Map<고유값, ("socialId", socialId)> 를 가지고 있다고 볼 수 있어요
    - 그래서 고유한값으로 ("socialId", socialId)를 가져오고, "socialId"를 통해 socialId를 가져올 수 있는 것이죠. 
        ```java
        public class HttpSessions {
            private static final Map<String, HttpSession> SESSIONS = new HashMap<>();
        
            public static void addSession(final String sessionId, final HttpSession httpSession) {
                SESSIONS.put(sessionId, httpSession);
            }
        
            public static HttpSession getSession(final String sessionId) {
                return SESSIONS.get(sessionId);
            }
        
            public static void remove(final String sessionId) {
                SESSIONS.remove(sessionId);
            }
        
            private HttpSessions() {
            }
        }
        
        public class HttpSession {
            private final String sessionId;
            private final Map<String, Object> values = new HashMap<>();
        
            private HttpSession(final String sessionId) {
                this.sessionId = sessionId;
            }
        
            public static HttpSession of(String sessionId) {
                final HttpSession httpSession = new HttpSession(sessionId);
                HttpSessions.addSession(sessionId, httpSession);
                return httpSession;
            }
        
            public void setAttribute(final String name, final Object value) {
                values.put(name, value);
            }
        
            public Object getAttribute(final String name) {
                return values.get(name);
            }
        
            public void removeAttribute(final String name) {
                values.remove(name);
            }
        
            public void invalidate() {
                HttpSessions.remove(this.sessionId);
            }
        
            public String getSessionId() {
                return sessionId;
            }
        }
        ```
        
## Network nolto.app 연결과정
1. 어플리케이션 레이어: HTTP Request 작성
2. 트랜스포트 레이어: SP(start-port) - DP(dest-port) 지정
3. 인터넷 레이어: SA(start-ip) - DA(dest-ip) 지정
    - DNS는 UDP로 통신
4. 이더넷
    - 이제 MAC 주소로 보내자 (실제 찐으로 모뎀에 물리적으로 할당된 이름)
    - 넓은 세상으로 나가자!
    - ARP 프로토콜을 사용하여 IP주소를 MAC주소로 변환    
        - 다음 라우터까지의 맥주소!
        - iptable 맥주소와 ip를 매핑해둠

## HTTP Request는 어떻게 세상에 전달되어 서버에게 전달되는가?

## DNS는 어떻게 동작하는가?

## 놀토의 깃 브랜치 전략

## 놀토 인프라
1. Why replication?
2. Why load-balancing?

## 놀토 JPA
1. Persist + All로도 안사라짐
2. N+1
    - fetch
    - batchSize