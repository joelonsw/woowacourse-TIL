### 2021-11-21

## JPA OneToOne
- *참고 1: https://www.baeldung.com/jpa-one-to-one*
- *참고 2: https://ict-nroo.tistory.com/126*
- *참고 3: http://wonwoo.ml/index.php/post/1530*
- *참고 4: https://kwonnam.pe.kr/wiki/java/jpa/one-to-one*
- **일대일 관계**
    - 주 테이블이나 대상 테이블 중에서 FK를 넣을 테이블 선택 가능
    - JPA 다대일 관계와 어노테이션만 다르고 거의 유사함
    - 외래키가 있는 곳이 "외래키 관리자" (연관관계의 주인)

- **예시**
    - 한 유저당 <-> 하나의 메일 주소
    - [User]
        - Address에 `@OneToOne`
        - `@JoinColumn`을 통해서 User 테이블에 Address의 PK를 어찌 저장할지 명명할 수 있음
            - 이를 명명함으로써 FK의 관리자로 명시할 수 있음!
        ```java
        @Entity
        @Table(name = "users")
        public class User {
            
            @Id
            @GeneratedValue(strategy = GenerationType.AUTO)
            @Column(name = "id")
            private Long id;
            //... 
        
            @OneToOne(cascade = CascadeType.ALL)
            @JoinColumn(name = "address_id", referencedColumnName = "id")
            private Address address;
        
            // ... getters and setters
        }
        ```
    - [Address]
        - 여기에도 `@OneToOne` 통해서 양방향 매핑
        ```java      
        @Entity
        @Table(name = "address")
        public class Address {
        
          @Id
          @GeneratedValue(strategy = GenerationType.AUTO)
          @Column(name = "id")
          private Long id;
          //...
        
          @OneToOne(mappedBy = "address")
          private User user;
        
          //... getters and setters
        }
        ```

- **일대일 관계는 Shared PK를 가질 수 있다!**
    - 어차피 너<->나 일대일 매칭이면 PK를 공유할 수 있겠지?
    - 굳이 다른 칼럼으로 FK로 매칭하지 않고 PK를 공유하자!
    - 예시
        ```java
        @Entity
        @Table(name = "users")
        public class User {
        
            @Id
            @GeneratedValue(strategy = GenerationType.AUTO)
            @Column(name = "id")
            private Long id;
        
            //...
        
            @OneToOne(mappedBy = "user", cascade = CascadeType.ALL)
            @PrimaryKeyJoinColumn // <= User의 PK를 Address의 FK로 연관짓겠다
            private Address address;
        
            //... getters and setters
        }
        
        @Entity
        @Table(name = "address")
        public class Address {
        
            @Id
            @Column(name = "user_id") // <= Generated 말고 이걸로!
            private Long id;
        
            //...
        
            @OneToOne
            @MapsId // <= PK가 User 엔티티로 복사되겠다
            @JoinColumn(name = "user_id")
            private User user;
           
            //... getters and setters
        }
        ```

- **주의할 점!**
    - 안타깝게도 Lazy로딩이 적용되지 않음!
        1. null값이 가능한 OneToOne은 프록시로 못 감쌈
        2. 만약 null 값이 가능한 OneToOne에 프록시 객체 넣으면, 그 순간 null이 또 아니게 됨
        3. 기본적으로 JPA 구현체는 OneToOne 관계에 Lazy 허용 안 함!

## `@JoinColumn` 을 안쓴다면 네이밍 규칙
- *참고: https://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/JoinColumn.html*
- **`@JoinColumn` 뜻**
    - 엔티티를 조인하도록 하는 칼럼의 명세를 정의합니다.

- **name 속성**
    - FK 칼럼의 네이밍을 지정한다
    - 규칙
        - `@OneToOne` 혹은 `@ManyToOne` 이라면, FK는 Source 엔티티에 붙음
        - 단방향 `@OneToMany`라면, FK는 Target 엔티티에 붙음
        - `@ManyToMany` || `@OneToOne` || 양방향 `@ManyToOne`/`@OneToMany` 라면 FK는 Join Table에 붙음
    - name이 없다면!
        - "참조엔티티_PK칼럼" 으로 FK 네이밍이 결정됨!

## 자바 쓰레드
- **미션에서 내가 쓰레드를 어찌 사용했더라?**
- **Spring 톰캣에서는 쓰레드를 몇 개나, 어찌 사용하지?**
